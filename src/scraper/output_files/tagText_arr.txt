["\n","\n","\n    ","Type erasure and reification - Eli Bendersky's website","\n    ","\n    ","\n    ","\n    ","\n\n    ","\n\n    ","\n        ","\n    ","\n\n    ","\n    ","\n\n        ","\n\n","\n","\n\n","\n    ","\n        ","\n            ","\n                ","Toggle navigation","\n                ","\n                ","\n                ","\n            ","\n            ","\n                ","\nEli Bendersky's website            ","\n        ","\n        ","\n            ","\n                ","\n                    ","\n                        ","\n                        ","About","\n                    ","\n                ","\n                ","\n                    ","\n                        ","\n                        ","Projects","\n                    ","\n                ","\n                ","\n                    ","\n                        ","\n                        ","Archives","\n                    ","\n                ","\n            ","\n        ","\n        ","\n    ","\n"," ","\n\n","\n    ","\n    ","\n        ","\n            ","\n                ","\n                    ","\n                        Type erasure and reification\n                    ","\n                ","\n            ","\n            ","\n                ","\n                    ","\n","\n    ","\n        ","\n        "," December 05, 2018 at 05:10","\n    ","\n","Tags","\n    ","Programming","\n        ,\n    ","C & C++","\n        ,\n    ","Python","\n","                    ","\n                ","\n                ","In this post I'd like to discuss the concepts of ","type erasure"," and\n","reification"," in programming languages. I don't intend to dive very deeply into\nthe specific rules of any particular language; rather, the post is going to\npresent several simple examples in multiple languages, hoping to provide enough\nintuition and background for a more serious study, if necessary. As you'll\nsee, the actual concepts are very simple and familiar. Deeper details of\nspecific languages pertain more to the idiosyncrasies of those languages'\nsemantics and implementations.","\n","Important note: in C++ there is a programming pattern called ","type erasure",",\nwhich is quite distinct from what I'm trying to describe here ","[1]",". I'll be\nusing C++ examples here, but that's to demonstrate how the original concepts\napply in C++. The programming pattern will be covered in a separate post.","\n","\n","Types at compile time, no types at run-time","\n","The title of this section is a \"one short sentence\" explanation of what type\nerasure means. With few exceptions, it only applies to languages with some\ndegree of compile time (a.k.a. ","static",") type checking. The basic principle\nshould be immediately familiar to folks who have some idea of what machine code\ngenerated from low-level languages like C looks like. While C has static typing,\nthis only matters in the compiler - the generated code is completely oblivious\nto types.","\n","For example, consider the following C snippet:","\n","typedef"," ","struct"," ","Frob_t"," ","{","\n","  ","int"," ","x",";","\n","  ","int"," ","y",";","\n","  ","int"," ","arr","[","10","];","\n","}"," ","Frob",";","\n\n","int"," ","extract","(","Frob","*"," ","frob",")"," ","{","\n","  ","return"," ","frob","->","y"," ","*"," ","frob","->","arr","[","7","];","\n","}","\n","\n","When compiling the function ","extract",", the compiler will perform type\nchecking. It won't let us access fields that were not declared in the struct,\nfor example. Neither will it let us pass a pointer to a different struct (or to\na ","float",") into ","extract",". But once it's done helping us, the compiler\ngenerates code which is completely type-free:","\n","0:   8b 47 04                mov    0x4(%rdi),%eax\n3:   0f af 47 24             imul   0x24(%rdi),%eax\n7:   c3                      retq\n","\n","The compiler is familiar with the ","stack frame layout"," and\nother specifics of the ABI, and generates code that assumes a correct type of\nstructure was passed in. If the actual type is not what this function expects,\nthere will be trouble (either accessing unmapped memory, or accessing wrong\ndata).","\n","A slightly adjusted example will clarify this:","\n","int"," ","extract_cast","(","void","*"," ","p",")"," ","{","\n","  ","Frob","*"," ","frob"," ","="," ","p",";","\n","  ","return"," ","frob","->","y"," ","*"," ","frob","->","arr","[","7","];","\n","}","\n","\n","The compiler will generate exactly identical code from this function, which in\nitself a good indication of when the types matter and when they don't. What's\nmore interesting is that ","extract_cast"," makes it extremely easy for\nprogrammers to shoot themselves in the foot:","\n","SomeOtherStruct"," ","ss",";","\n","extract_cast","(","&","ss",");","    ","// oops","\n","\n","In general, ","type erasure"," is a concept that descibes these semantics of a\nlanguage. Types matter to the compiler, which uses them to generate code and\nhelp the programmer avoid errors. Once everything is type-checked, however, the\ntypes are simply ","erased"," and the code the compiler generates is oblivious to\nthem. The next section will put this in context by comparing to the opposite\napproach.","\n","\n","\n","Reification - retaining types at run-time","\n","While erasure means the compiler discards all type information for the actual\ngenerated code, ","reification"," is the other way to go - types are retained at\nrun-time and used for perform various checks. A classical example from Java will\nhelp demonstrate this:","\n","class"," ","Main"," ","{","\n","  ","public"," ","static"," ","void"," ","main","(","String","[]"," ","args",")"," ","{","\n","    ","String"," ","strings","[]"," ","="," ","{","\"a\"",","," ","\"b\"","};","\n","    ","Object"," ","objects","[]"," ","="," ","strings",";","\n","    ","objects","[","0","]"," ","="," ","5",";","\n","  ","}","\n","}","\n","\n","This code creates an array of ","String",", and converts it to a generic array of\n","Object",". This is valid because arrays in Java\n","are covariant",",\nso the compiler doesn't complain. However, in the next line we try to assign\nan integer into the array. This happens to fail with an exception ","at run-time",":","\n","Exception in thread \"main\" java.lang.ArrayStoreException: java.lang.Integer\n    at Main.main(Main.java:5)\n","\n","A type check was inserted into the generated code, and it fired when an\nincorrect assignment was attempted. In other words, the type of ","objects"," is\n","reified",". Reification is defined roughly as \"taking something abstract and\nmaking it real/concrete\", which when applied to types means \"compile-time types\nare converted to actual run-time entities\".","\n","C++ has some type reification support as well, e.g. with ","dynamic_cast",":","\n","struct"," ","Base"," ","{","\n","  ","virtual"," ","void"," ","basefunc","()"," ","{","\n","    ","printf","(","\"basefunc","\\n","\"",");","\n","  ","}","\n","};","\n\n","struct"," ","Derived"," ",":"," ","public"," ","Base"," ","{","\n","  ","void"," ","derivedfunc","()"," ","{","\n","    ","printf","(","\"derived","\\n","\"",");","\n","  ","}","\n","};","\n\n","void"," ","call_derived","(","Base","*"," ","b",")"," ","{","\n","  ","Derived","*"," ","d"," ","="," ","dynamic_cast","<","Derived","*>","(","b",");","\n","  ","if"," ","(","d"," ","!="," ","nullptr",")"," ","{","\n","    ","d","->","derivedfunc","();","\n","  ","}"," ","else"," ","{","\n","    ","printf","(","\"cast failed","\\n","\"",");","\n","  ","}","\n","}","\n","\n","We can call ","call_derived"," thus:","\n","int"," ","main","()"," ","{","\n","  ","Derived"," ","d",";","\n","  ","call_derived","(","&","d",");","\n\n","  ","Base"," ","b",";","\n","  ","call_derived","(","&","b",");","\n","}","\n","\n","The first call will successfully invoke ","derivedfunc","; the second will not,\nbecause the ","dynamic_cast"," will return ","nullptr"," at run-time. This is\nbecause we're using C++'s ","run-time type information"," (RTTI) capabilities here,\nwhere an actual representation of the type is stored in the generated code (most\nlikely attached to the vtable which every polymorphic object points to). C++\nalso has the ","typeid"," feature, but I'm showing ","dynamic_cast"," since it's the\none most commonly used.","\n","Note particularly the differences between this sample and the C sample in the\nbeginning of the post. Conceptually, it's similar - we use a pointer to a\ngeneral type (in C that's ","void*",", in the C++ example we use a base type) to\ninteract with concrete types. Whereas in C there is no built-in run-time type\nfeature, in C++ we can use RTTI in some cases. With RTTI enabled,\n","dynamic_cast"," can be used to interact with the run-time (reified)\nrepresentation of types in a limited but useful way.","\n","\n","\n","Type erasure and Java generics","\n","One place where folks not necessarily familiar with programming language type\ntheory encounter erasure is Java generics, which were bolted onto the language\nafter a large amount of code has already been written. The designers of Java\nfaced the binary compatibility challenge, wherein they wanted code compiled with\nnewer Java compilers to run on older VMs.","\n","The solution was to use type erasure to implement generics entirely in the\ncompiler. Here's a quote from the ","official Java generics tutorial",":","\n","\n","Generics were introduced to the Java language to provide tighter type checks\nat compile time and to support generic programming. To implement generics, the\nJava compiler applies type erasure to:","\n","\n","Replace all type parameters in generic types with their bounds or Object if\nthe type parameters are unbounded. The produced bytecode, therefore,\ncontains only ordinary classes, interfaces, and methods.","\n","Insert type casts if necessary to preserve type safety.","\n","Generate bridge methods to preserve polymorphism in extended generic types.","\n","\n","\n","Here's a very simple example to demonstrate what's going on, taken from\n","a Stack Overflow answer",". This code:","\n","import"," ","java.util.List",";","\n","import"," ","java.util.ArrayList",";","\n\n","class"," ","Main"," ","{","\n","  ","public"," ","static"," ","void"," ","main","(","String","[]"," ","args",")"," ","{","\n","    ","List","<","String",">"," ","list"," ","="," ","new"," ","ArrayList","<","String",">","();","\n","    ","list",".","add","(","\"Hi\"",");","\n","    ","String"," ","x"," ","="," ","list",".","get","(","0",");","\n","    ","System",".","out",".","println","(","x",");","\n","  ","}","\n","}","\n","\n","Uses a generic ","List",". However, what the compiler creates prior to emitting\nbytecode is equivalent to:","\n","import"," ","java.util.List",";","\n","import"," ","java.util.ArrayList",";","\n\n","class"," ","Main"," ","{","\n","  ","public"," ","static"," ","void"," ","main","(","String","[]"," ","args",")"," ","{","\n","    ","List"," ","list"," ","="," ","new"," ","ArrayList","();","\n","    ","list",".","add","(","\"Hi\"",");","\n","    ","String"," ","x"," ","="," ","(","String",")"," ","list",".","get","(","0",");","\n","    ","System",".","out",".","println","(","x",");","\n","  ","}","\n","}","\n","\n","Here ","List"," is a container of ","Object",", so we can assign any element to it\n(similarly to the reification example shown in the previous section). The\ncompiler then inserts a cast when accessing that element as a string. In this\ncase the compiler will adamantly preserve type safety and won't let us do\n","list.add(5)"," in the original snippet, because it sees that ","list"," is a\n","List<String>",". Therefore, the cast to ","(String)"," should be safe.","\n","Using type erasure to implement generics with backwards compatibility is a neat\nidea, but it has its issues. Some folks complain that not having the types\navailable at runtime is a limitation (e.g. not being able to use ","instanceof","\nand other reflection capabilities). Other languages, like C# and Dart 2, have\n","reified generics"," which do preserve the type information at run-time.","\n","\n","\n","Reification in dynamically typed languages","\n","I hope it's obvious that the theory and techniques described above only apply\nto statically-typed languages. In dynamically-typed languages, like Python,\nthere is almost no concept of types at compile-time, and types are a fully\nreified concept. Even trivial errors like:","\n","class"," ","Foo",":","\n  ","def"," ","bar","(","self","):"," ","pass","\n\n","f"," ","="," ","Foo","()","\n","f",".","joe","()","         ","# <--- calling non-existent method","\n","\n","Fire at run-time, because there's no static type checking ","[2]",". Types obviously\nexist at run-time, with functions like ","type()"," and ","isinstance()"," providing\ncomplete reflection capabilities. The ","type()"," function can even create new\ntypes ","entirely at run-time",".","\n","\n","\n","\n","\n","[1]","But it's most likely what you'll get to if you google for\n\"c++ type erasure\".","\n","\n","\n","\n","\n","\n","[2]","To be clear - this is not a bug; it's a feature of Python. A new method\ncan be added to classes dynamically at runtime (here, some code could\nhave defined a ","joe"," method for ","Foo"," before the ","f.joe()","\ninvocation), and the compiler has absolutely no way of knowing this could\nor couldn't happen. So it has to assume such invocations are valid and\nrely on run-time checking to avoid serious errors like memory corruption.","\n","\n","\n","\n\n            ","\n            ","\n","\n","\n","\nFor comments, please send me\n"," an email",".\n","\n","        ","\n    ","\n\n    ","\n","\n","\n   ","\n      ","\n      ","\n         ","\n            \169 2003-2024 Eli Bendersky\n         ","\n         "," ","Back to top","\n      ","\n   ","\n","\n","\n\n","\n","\n\n","\n","\n","\n"]
