type erasure and reification - eli bendersky's website
toggle navigation eli bendersky's website about projects archives
type erasure and reification
december 05, 2018 at 05:10
tags programming , c & c++ , python
types at compile time, no types at run-time
for example, consider the following c snippet:
typedef struct frob_t {
int x ;
int y ;
int arr [ 10 ];
} frob ; int extract ( frob * frob ) {
return frob -> y * frob -> arr [ 7 ];
}
0: 8b 47 04 mov 0x4(%rdi),%eax 3: 0f af 47 24 imul 0x24(%rdi),%eax 7: c3 retq
a slightly adjusted example will clarify this:
int extract_cast ( void * p ) {
frob * frob = p ;
return frob -> y * frob -> arr [ 7 ];
}
someotherstruct ss ;
extract_cast ( & ss ); // oops
reification - retaining types at run-time
while erasure means the compiler discards all type information for the actual generated code, reification is the other way to go - types are retained at run-time and used for perform various checks. a classical example from java will help demonstrate this:
class main {
public static void main ( string [] args ) {
string strings [] = { "a" , "b" };
object objects [] = strings ;
objects [ 0 ] = 5 ;
}
}
exception in thread "main" java.lang.arraystoreexception: java.lang.integer at main.main(main.java:5)
c++ has some type reification support as well, e.g. with dynamic_cast :
struct base {
virtual void basefunc () {
printf ( "basefunc \n " );
}
}; struct derived : public base {
void derivedfunc () {
printf ( "derived \n " );
}
}; void call_derived ( base * b ) {
derived * d = dynamic_cast < derived *> ( b );
if ( d != nullptr ) {
d -> derivedfunc ();
} else {
printf ( "cast failed \n " );
}
}
we can call call_derived thus:
int main () {
derived d ;
call_derived ( & d ); base b ;
call_derived ( & b );
}
type erasure and java generics
replace all type parameters in generic types with their bounds or object if the type parameters are unbounded. the produced bytecode, therefore, contains only ordinary classes, interfaces, and methods.
insert type casts if necessary to preserve type safety.
generate bridge methods to preserve polymorphism in extended generic types.
import java.util.list ;
import java.util.arraylist ; class main {
public static void main ( string [] args ) {
list < string > list = new arraylist < string > ();
list . add ( "hi" );
string x = list . get ( 0 );
system . out . println ( x );
}
}
import java.util.list ;
import java.util.arraylist ; class main {
public static void main ( string [] args ) {
list list = new arraylist ();
list . add ( "hi" );
string x = ( string ) list . get ( 0 );
system . out . println ( x );
}
}
reification in dynamically typed languages
class foo : def bar ( self ): pass f = foo ()
f . joe () # <--- calling non-existent method
fire at run-time, because there's no static type checking [2] . types obviously exist at run-time, with functions like type() and isinstance() providing complete reflection capabilities. the type() function can even create new types entirely at run-time .
[1] but it's most likely what you'll get to if you google for "c++ type erasure".
for comments, please send me an email .
Â© 2003-2024 eli bendersky back to top
