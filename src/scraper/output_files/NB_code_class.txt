type erasure and reification - eli bendersky's website
toggle navigation eli bendersky's website about projects archives
december 05, 2018 at 05:10
tags programming , c & c++ , python
typedef struct frob_t {
int x ;
int y ;
int arr [ 10 ];
} frob ; int extract ( frob * frob ) {
return frob -> y * frob -> arr [ 7 ];
}
0: 8b 47 04 mov 0x4(%rdi),%eax 3: 0f af 47 24 imul 0x24(%rdi),%eax 7: c3 retq
int extract_cast ( void * p ) {
frob * frob = p ;
return frob -> y * frob -> arr [ 7 ];
}
someotherstruct ss ;
extract_cast ( & ss ); // oops
reification - retaining types at run-time
class main {
public static void main ( string [] args ) {
string strings [] = { "a" , "b" };
object objects [] = strings ;
objects [ 0 ] = 5 ;
}
}
c++ has some type reification support as well, e.g. with dynamic_cast :
struct base {
virtual void basefunc () {
printf ( "basefunc \n " );
}
}; struct derived : public base {
void derivedfunc () {
printf ( "derived \n " );
}
}; void call_derived ( base * b ) {
derived * d = dynamic_cast < derived *> ( b );
if ( d != nullptr ) {
d -> derivedfunc ();
} else {
printf ( "cast failed \n " );
}
}
we can call call_derived thus:
int main () {
derived d ;
call_derived ( & d ); base b ;
call_derived ( & b );
}
insert type casts if necessary to preserve type safety.
import java.util.list ;
import java.util.arraylist ; class main {
public static void main ( string [] args ) {
list < string > list = new arraylist < string > ();
list . add ( "hi" );
string x = list . get ( 0 );
system . out . println ( x );
}
}
import java.util.list ;
import java.util.arraylist ; class main {
public static void main ( string [] args ) {
list list = new arraylist ();
list . add ( "hi" );
string x = ( string ) list . get ( 0 );
system . out . println ( x );
}
}
class foo : def bar ( self ): pass f = foo ()
f . joe () # <--- calling non-existent method
[1] but it's most likely what you'll get to if you google for "c++ type erasure".
for comments, please send me an email .
