
    _parameter_constraints: dict = {**BaseLabelPropagation._parameter_constraints}
    _parameter_constraints["alpha"] = [Interval(Real, 0, 1, closed="neither")]

    def __init__(
        self,
        kernel="rbf",
        *,
        gamma=20,
        n_neighbors=7,
        alpha=0.2,
        max_iter=30,
        tol=1e-3,
        n_jobs=None,
    ):
        # this one has different base parameters
        super().__init__(
            kernel=kernel,
            gamma=gamma,
            n_neighbors=n_neighbors,
            alpha=alpha,
            max_iter=max_iter,
            tol=tol,
            n_jobs=n_jobs,
        )

    def _build_graph(self):
        """Graph matrix for Label Spreading computes the graph laplacian"""
        # compute affinity matrix (or gram matrix)
        if self.kernel == "knn":
            self.nn_fit = None
        n_samples = self.X_.shape[0]
        affinity_matrix = self._get_kernel(self.X_)
        laplacian = csgraph_laplacian(affinity_matrix, normed=True)
        laplacian = -laplacian
        if sparse.issparse(laplacian):
            diag_mask = laplacian.row == laplacian.col
            laplacian.data[diag_mask] = 0.0
        else:
            laplacian.flat[:: n_samples + 1] = 0.0  # set diag to 0.0
        return laplacian
      
    typedef struct Frob_t {
      int x;
      int y;
      int arr[10];
    } Frob;

    int extract(Frob* frob) {
      return frob->y * frob->arr[7];
    }

    0:   8b 47 04                mov    0x4(%rdi),%eax
    3:   0f af 47 24             imul   0x24(%rdi),%eax
    7:   c3                      retq

    int extract_cast(void* p) {
      Frob* frob = p;
      return frob->y * frob->arr[7];
    }

    SomeOtherStruct ss;
    extract_cast(&ss);    // oops

    class Main {
      public static void main(String[] args) {
        String strings[] = {"a", "b"};
        Object objects[] = strings;
        objects[0] = 5;
      }
    }

    Exception in thread "main" java.lang.ArrayStoreException: java.lang.Integer
        at Main.main(Main.java:5)

    struct Base {
      virtual void basefunc() {
        printf("basefunc\n");
      }
    };

    struct Derived : public Base {
      void derivedfunc() {
        printf("derived\n");
      }
    };

    void call_derived(Base* b) {
      Derived* d = dynamic_cast<Derived*>(b);
      if (d != nullptr) {
        d->derivedfunc();
      } else {
        printf("cast failed\n");
      }
    }

    int main() {
      Derived d;
      call_derived(&d);

      Base b;
      call_derived(&b);
    }

    import java.util.List;
    import java.util.ArrayList;

    class Main {
      public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        list.add("Hi");
        String x = list.get(0);
        System.out.println(x);
      }
    }

    import java.util.List;
    import java.util.ArrayList;

    class Main {
      public static void main(String[] args) {
        List list = new ArrayList();
        list.add("Hi");
        String x = (String) list.get(0);
        System.out.println(x);
      }
    }

    class Foo:
      def bar(self): pass

    f = Foo()
    f.joe()         # <--- calling non-existent method
