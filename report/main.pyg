
        fillTrue :: [Bool] -> [Bool]
        fillTrue [] = []
        fillTrue [a] = [a]
        fillTrue (False:False:xs) = False:fillTrue (False:xs)
        fillTrue (False:True:xs) = False:fillTrue (True:xs)

        -- fill True for elements after a <pre> tag starts
        fillTrue (True:False:xs) = True:fillTrue (True:xs)

        -- seeing 2 consecutive Trues denotes end of <pre> tag, so skip them
        fillTrue (True:True:xs) = True:True:fillTrue (xs)




        separateTextCode :: [Soup.Tag String] -> ([Soup.Tag String], [Soup.Tag String])
        separateTextCode parsed_tags =
    let bool_mapping_open = Prelude.map (Soup.isTagOpenName "pre") parsed_tags
        bool_mapping_close = Prelude.map (Soup.isTagCloseName "pre") parsed_tags

        -- do element-vise or of the two lists
        bool_mapping1 =  Prelude.zipWith (||) bool_mapping_open bool_mapping_close

        filled_true_pre = fillTrue bool_mapping1
        combined_pre = Prelude.zip filled_true_pre parsed_tags
        preTags = Prelude.map snd (Prelude.filter (fst) combined_pre)

        bool_mapping_img_open = Prelude.map (Soup.isTagOpenName "img") parsed_tags
        bool_mapping_img_close = Prelude.map (Soup.isTagCloseName "img") parsed_tags
        bool_mapping2 =  Prelude.zipWith (||) bool_mapping_img_open bool_mapping_img_close

        bool_mapping =  Prelude.zipWith (||) bool_mapping1 bool_mapping2

        filled_true = fillTrue bool_mapping
        -- zip parsed_tags list with the boolean list and Prelude.filter elements of the first list based on the second list to create tuple list
        combined = Prelude.zip filled_true parsed_tags
        -- get tags of tuples from combined where the boolean is false
        nonPreTags = Prelude.map snd (Prelude.filter (\(a,_) -> not a) combined)

    in (preTags, nonPreTags)
